Index: src/xerus/softwarechallenge/logic2018/CommonLogic.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package xerus.softwarechallenge.logic2018\n\nimport sc.plugin2018.*\nimport sc.plugin2018.util.GameRuleLogic\nimport sc.shared.PlayerColor\nimport xerus.ktutil.forRange\nimport xerus.ktutil.square\nimport xerus.ktutil.to\nimport xerus.softwarechallenge.util.F\nimport xerus.softwarechallenge.util.addMove\nimport java.util.*\nimport kotlin.math.pow\n\nabstract class CommonLogic : LogicBase() {\n\t\n\t/** Uses a function to gauge the worth of the carrots at the given position\n\t * @param x carrots\n\t * @param y distance to goal\n\t */\n\tprotected fun carrotPoints(x: Double, y: Double) =\n\t\t\t(1.1.pow(-((x - y.pow(1.6)) / (40 + y)).square) * 5 + x / (100 - y)) * carrotParam\n\t\n\t@F val carrotParam = params[0]\n\t@F val saladParam = params[1]\n\t\n\toverride fun evaluate(state: GameState, color: PlayerColor): Double {\n\t\tval player = state.getPlayer(color)\n\t\tvar points = player.fieldIndex + 120.0 - state.turn * 3\n\t\tval distanceToGoal = 65.minus(player.fieldIndex).toDouble()\n\t\t\n\t\t// Salat und Karten\n\t\tpoints -= saladParam * player.salads * (5 - Math.log(distanceToGoal))\n\t\tpoints += player.ownsCardOfType(CardType.EAT_SALAD).to(saladParam * 0.8, 0.0)\n\t\tpoints += player.ownsCardOfType(CardType.TAKE_OR_DROP_CARROTS).to(carrotParam * 1.3, 0.0)\n\t\tpoints += player.cards.size * 2\n\t\t\n\t\t// Karotten\n\t\tpoints += carrotPoints(player.carrots.toDouble(), distanceToGoal) * 3\n\t\tval opponent = state.getPlayer(color.opponent())\n\t\tpoints -= carrotPoints(opponent.carrots.toDouble(), 65.minus(opponent.fieldIndex).toDouble())\n\t\t\n\t\t// Zieleinlauf\n\t\treturn points + goalPoints(player)\n\t}\n\t\n\toverride fun GameState.findMoves(): List<Move> {\n\t\tval player = currentPlayer\n\t\tval index = player.fieldIndex\n\t\tval currentField = fieldTypeAt(index)\n\t\tif (currentField == FieldType.SALAD && player.lastNonSkipAction !is EatSalad)\n\t\t\treturn listOf(Move(EatSalad()))\n\t\t\n\t\tval allMoves = ArrayList<Move>()\n\t\tval moves = ArrayList<Move>()\n\t\tif (currentField == FieldType.CARROT) {\n\t\t\tif (shouldDropCarrots(10, player.carrots, index))\n\t\t\t\tmoves.addMove(ExchangeCarrots(-10))\n\t\t\tmoves.addMove(ExchangeCarrots(10))\n\t\t}\n\t\t\n\t\tfun newMove(move: Move, condition: Boolean) {\n\t\t\tif (condition)\n\t\t\t\tmoves.add(move)\n\t\t\telse if (moves.isEmpty())\n\t\t\t\tallMoves.add(move)\n\t\t}\n\t\t\n\t\tval hedgehog = getPreviousFieldByType(FieldType.HEDGEHOG, index)\n\t\tif (hedgehog != -1 && !isOccupied(hedgehog))\n\t\t\tmoves.addMove(FallBack())\n\t\t\n\t\tval otherPos = otherPos\n\t\tforRange(1, GameRuleLogic.calculateMoveableFields(player.carrots).coerceAtMost(64 - index) + 1) { i ->\n\t\t\tval newPos = index + i\n\t\t\tval newType = fieldTypeAt(newPos)\n\t\t\tif ((otherPos == newPos && newPos != 64) || newType == FieldType.HEDGEHOG)\n\t\t\t\treturn@forRange\n\t\t\tval advance = Move(Advance(i))\n\t\t\tval newCarrots = player.carrots - GameRuleLogic.calculateCarrots(i)\n\t\t\twhen (newType) {\n\t\t\t\tFieldType.GOAL -> {\n\t\t\t\t\tif (newCarrots <= 10 && !player.hasSalad)\n\t\t\t\t\t\treturn listOf(advance)\n\t\t\t\t}\n\t\t\t\tFieldType.SALAD -> {\n\t\t\t\t\tif (player.hasSalad)\n\t\t\t\t\t\tmoves.add(advance)\n\t\t\t\t}\n\t\t\t\tFieldType.HARE -> {\n\t\t\t\t\tval cards = player.cards\n\t\t\t\t\tif (cards.isEmpty())\n\t\t\t\t\t\treturn@forRange\n\t\t\t\t\tif (CardType.EAT_SALAD in cards && player.hasSalad)\n\t\t\t\t\t\tnewMove(advance.addCard(CardType.EAT_SALAD), newPos > 42 || newPos < otherPos || player.salads == 1)\n\t\t\t\t\tif (CardType.TAKE_OR_DROP_CARROTS in cards) {\n\t\t\t\t\t\tnewMove(advance.addCard(CardType.TAKE_OR_DROP_CARROTS, 20), CardType.EAT_SALAD !in cards || newPos > otherPos)\n\t\t\t\t\t\tif (shouldDropCarrots(20, newCarrots, newPos))\n\t\t\t\t\t\t\tmoves.add(advance.addCard(CardType.TAKE_OR_DROP_CARROTS, -20))\n\t\t\t\t\t\tif (shouldDropCarrots(0, newCarrots, newPos))\n\t\t\t\t\t\t\tmoves.add(advance.addCard(CardType.TAKE_OR_DROP_CARROTS, 0))\n\t\t\t\t\t}\n\t\t\t\t\tif (CardType.HURRY_AHEAD in cards && otherPos > newPos && accessible(otherPos + 1, newCarrots)) {\n\t\t\t\t\t\tval hurry = advance.addCard(CardType.HURRY_AHEAD)\n\t\t\t\t\t\twhen (fieldTypeAt(otherPos + 1)) {\n\t\t\t\t\t\t\tFieldType.HARE -> {\n\t\t\t\t\t\t\t\tif (cards.size > 1) {\n\t\t\t\t\t\t\t\t\tif (CardType.FALL_BACK in cards && accessible(otherPos - 1, newCarrots)) {\n\t\t\t\t\t\t\t\t\t\tval newField = fieldTypeAt(otherPos - 1)\n\t\t\t\t\t\t\t\t\t\tif (newField != FieldType.HARE)\n\t\t\t\t\t\t\t\t\t\t\tmoves.add(hurry.addCard(CardType.FALL_BACK))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (CardType.TAKE_OR_DROP_CARROTS in cards) {\n\t\t\t\t\t\t\t\t\t\tmoves.add(hurry.addCard(CardType.TAKE_OR_DROP_CARROTS, 20))\n\t\t\t\t\t\t\t\t\t\tif (shouldDropCarrots(20, newCarrots, otherPos + 1))\n\t\t\t\t\t\t\t\t\t\t\tmoves.add(hurry.addCard(CardType.TAKE_OR_DROP_CARROTS, -20))\n\t\t\t\t\t\t\t\t\t\tif (shouldDropCarrots(0, newCarrots, otherPos + 1))\n\t\t\t\t\t\t\t\t\t\t\tmoves.add(hurry.addCard(CardType.TAKE_OR_DROP_CARROTS, 0))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse -> moves.add(hurry)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (CardType.FALL_BACK in cards && otherPos < newPos && accessible(otherPos - 1, newCarrots)) {\n\t\t\t\t\t\tval fall = advance.addCard(CardType.FALL_BACK)\n\t\t\t\t\t\twhen (fieldTypeAt(otherPos - 1)) {\n\t\t\t\t\t\t\tFieldType.HARE -> {\n\t\t\t\t\t\t\t\tif (cards.size > 1) {\n\t\t\t\t\t\t\t\t\tif (CardType.HURRY_AHEAD in cards && accessible(otherPos + 1, newCarrots)) {\n\t\t\t\t\t\t\t\t\t\tval newField = fieldTypeAt(otherPos + 1)\n\t\t\t\t\t\t\t\t\t\tif (newField != FieldType.HARE)\n\t\t\t\t\t\t\t\t\t\t\tnewMove(fall.addCard(CardType.HURRY_AHEAD), newField == FieldType.SALAD)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (CardType.EAT_SALAD in cards && player.hasSalad)\n\t\t\t\t\t\t\t\t\t\tmoves.add(fall.addCard(CardType.EAT_SALAD))\n\t\t\t\t\t\t\t\t\tif (CardType.TAKE_OR_DROP_CARROTS in cards) {\n\t\t\t\t\t\t\t\t\t\tif (CardType.EAT_SALAD !in cards)\n\t\t\t\t\t\t\t\t\t\t\tmoves.add(fall.addCard(CardType.TAKE_OR_DROP_CARROTS, 20))\n\t\t\t\t\t\t\t\t\t\tif (shouldDropCarrots(20, newCarrots, otherPos - 1))\n\t\t\t\t\t\t\t\t\t\t\tmoves.add(fall.addCard(CardType.TAKE_OR_DROP_CARROTS, -20))\n\t\t\t\t\t\t\t\t\t\tif (shouldDropCarrots(0, newCarrots, otherPos - 1))\n\t\t\t\t\t\t\t\t\t\t\tmoves.add(fall.addCard(CardType.TAKE_OR_DROP_CARROTS, 0))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse -> moves.add(fall)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse -> moves.add(advance)\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn when {\n\t\t\tmoves.isNotEmpty() -> moves\n\t\t\tallMoves.isNotEmpty() -> allMoves\n\t\t\telse -> skip\n\t\t}\n\t}\n\t\n\toverride fun GameState.predefinedMove(): Move? {\n\t\tval player = currentPlayer\n\t\tval pos = player.fieldIndex\n\t\tval otherPos = otherPos\n\t\tif (pos == 0 && fieldTypeAt(1) == FieldType.POSITION_2 && otherPos != 1)\n\t\t\treturn advanceTo(1)\n\t\t\n\t\treturn null\n\t}\n\t\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/xerus/softwarechallenge/logic2018/CommonLogic.kt	(date 1528131424000)
+++ src/xerus/softwarechallenge/logic2018/CommonLogic.kt	(date 1528168772000)
@@ -1,3 +1,5 @@
+@file:Suppress("NOTHING_TO_INLINE")
+
 package xerus.softwarechallenge.logic2018
 
 import sc.plugin2018.*
@@ -20,24 +22,34 @@
 	protected fun carrotPoints(x: Double, y: Double) =
 			(1.1.pow(-((x - y.pow(1.6)) / (40 + y)).square) * 5 + x / (100 - y)) * carrotParam
 	
+	protected inline fun carrotPoints(player: Player) = carrotPoints(player.carrots.toDouble(), player.distanceToGoal)
+	
+	protected fun saladPoints(salads: Int, distanceToGoal: Double) = saladParam * (currentPlayer.salads - salads) * (5 - Math.log(distanceToGoal))
+	
+	protected inline fun saladPoints(player: Player) = saladPoints(player.salads, player.distanceToGoal)
+	
+	protected inline val Player.distanceToGoal get() = 65.0 - fieldIndex
+	
 	@F val carrotParam = params[0]
 	@F val saladParam = params[1]
 	
 	override fun evaluate(state: GameState, color: PlayerColor): Double {
 		val player = state.getPlayer(color)
-		var points = player.fieldIndex + 120.0 - state.turn * 3
-		val distanceToGoal = 65.minus(player.fieldIndex).toDouble()
+		val index = player.fieldIndex
+		val distanceToGoal = 65.0 - index
+		var points = index - 20.0 - state.turn
 		
 		// Salat und Karten
-		points -= saladParam * player.salads * (5 - Math.log(distanceToGoal))
-		points += player.ownsCardOfType(CardType.EAT_SALAD).to(saladParam * 0.8, 0.0)
-		points += player.ownsCardOfType(CardType.TAKE_OR_DROP_CARROTS).to(carrotParam * 1.3, 0.0)
+		points += saladPoints(player.salads, distanceToGoal) // * 0.3
+		points += player.ownsCardOfType(CardType.EAT_SALAD).to(saladParam * 0.6, 0.0)
+		points += player.ownsCardOfType(CardType.TAKE_OR_DROP_CARROTS).to(carrotParam * 0.8, 0.0)
+		//if (fieldTypeAt(index) == FieldType.SALAD)
+		//	points += saladParam / 2
 		points += player.cards.size * 2
 		
 		// Karotten
 		points += carrotPoints(player.carrots.toDouble(), distanceToGoal) * 3
-		val opponent = state.getPlayer(color.opponent())
-		points -= carrotPoints(opponent.carrots.toDouble(), 65.minus(opponent.fieldIndex).toDouble())
+		points -= carrotPoints(state.getPlayer(color.opponent()))
 		
 		// Zieleinlauf
 		return points + goalPoints(player)
