Index: src/xerus/softwarechallenge/logic2018/Jumper3.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package xerus.softwarechallenge.logic2018\n\nimport sc.plugin2018.GameState\nimport sc.plugin2018.Move\nimport xerus.ktutil.createDir\nimport xerus.ktutil.forRange\nimport xerus.ktutil.helpers.Timer\nimport xerus.softwarechallenge.util.F\nimport xerus.softwarechallenge.util.MP\nimport xerus.softwarechallenge.util.str\nimport java.nio.file.Path\nimport java.util.*\nimport kotlin.collections.ArrayList\nimport kotlin.math.pow\n\nobject Jumper3 : CommonLogic() {\n\t\n\t/** Karotten, Salat */\n\toverride fun defaultParams() = doubleArrayOf(3.0, 20.0)\n\t\n\t/** sucht den besten Move per Breitensuche basierend auf dem aktuellen GameState */\n\toverride fun findBestMove(): Move? {\n\t\tval mp = MP()\n\t\t\n\t\tvar moves = currentState.findMoves()\n\t\tfor (move in moves) {\n\t\t\tval newState = currentState.test(move, moveOther = false) ?: continue\n\t\t\tif (newState.me.gewonnen())\n\t\t\t\treturn move\n\t\t\t// Evaluation\n\t\t\tval points = evaluate(newState)\n\t\t\tmp.update(move, points)\n\t\t\t// Queue\n\t\t\tqueue.add(rootNode.rootChild(move, newState, points))\n\t\t}\n\t\t\n\t\tvar bestMove = mp.obj\n\t\tif (currentTurn > 57)\n\t\t\treturn bestMove\n\t\tif (queue.size < 2) {\n\t\t\tif (bestMove != null) {\n\t\t\t\tlogger.info(\"Nur einen validen Zug gefunden: ${bestMove.str()}\")\n\t\t\t} else {\n\t\t\t\tbestMove = moves.first()\n\t\t\t\tlogger.warn(\"Keinen sinnvollen Zug gefunden, sende ${bestMove.str()}!\")\n\t\t\t}\n\t\t\treturn bestMove\n\t\t}\n\t\tlogger.info(\"Found: ${queue.joinToString()}\")\n\t\t\n\t\t// Breitensuche\n\t\tvar acceptedMoves = 0\n\t\tvar subDir: Path? = null\n\t\tvar divider = 1.0\n\t\tdepth = 1\n\t\tvar maxDepth = 5.coerceAtMost(60.minus(currentTurn) / 2)\n\t\tvar node = queue.pop()\n\t\tvar best = 0.0\n\t\tloop@ while (depth < maxDepth && queue.size > 0) {\n\t\t\tval nodeState = node.popState()\n\t\t\tnodeState.findMoves().mapNotNullTo(ArrayList()) { move ->\n\t\t\t\tval moveState = nodeState.clone()\n\t\t\t\tmove.setOrderInActions()\n\t\t\t\ttry {\n\t\t\t\t\tmove.perform(moveState)\n\t\t\t\t\tvar bestPoints = evaluate(moveState, myColor.opponent())\n\t\t\t\t\tval newState = moveState.quickMove(false)!!.second\n\t\t\t\t\tfor (move2 in newState.findMoves()) {\n\t\t\t\t\t\tval moveState2 = newState.clone()\n\t\t\t\t\t\tmove2.setOrderInActions()\n\t\t\t\t\t\tmove2.perform(moveState2)\n\t\t\t\t\t\tbestPoints = bestPoints.coerceAtLeast(evaluate(moveState2, myColor.opponent()))\n\t\t\t\t\t}\n\t\t\t\t\tNode(move, moveState, bestPoints, node.depth, node.dir)\n\t\t\t\t} catch (exception: Throwable) {\n\t\t\t\t\tlogger.error(\"Fehler bei enemy move: ${move.str()} caused $exception\\n\" + nodeState.str())\n\t\t\t\t\tnull\n\t\t\t\t}\n\t\t\t}.apply { sortDescending() }.take(2).forEach { stateNode ->\n\t\t\t\tnode.children.add(stateNode)\n\t\t\t\tval state = stateNode.popState()\n\t\t\t\tvar bestLocal = Double.NEGATIVE_INFINITY\n\t\t\t\tmoves = state.findMoves()\n\t\t\t\tforRange(0, moves.size) { i ->\n\t\t\t\t\tif (Timer.runtime() > 1700)\n\t\t\t\t\t\treturn@forRange\n\t\t\t\t\tval move = moves[i]\n\t\t\t\t\tval newState = state.test(move, i < moves.lastIndex, false) ?: return@forRange\n\t\t\t\t\t// Evaluation\n\t\t\t\t\tval points = evaluate(newState) / divider + node.points\n\t\t\t\t\tif (points > bestLocal)\n\t\t\t\t\t\tbestLocal = points\n\t\t\t\t\tif (points < best - 40.0 / divider)\n\t\t\t\t\t\treturn@forRange\n\t\t\t\t\tif (points > best)\n\t\t\t\t\t\tbest = points\n\t\t\t\t\t// Debug\n\t\t\t\t\tacceptedMoves++\n\t\t\t\t\tif (isDebug) subDir = node.dir?.resolve(\"%.1f: %s ㊝%s ✖%s %s\".format(points, move.str(), newState.me.strShortest(), newState.enemy.strShortest(), newState.enemy.lastNonSkipAction.str()))?.createDir()\n\t\t\t\t\t// Queue\n\t\t\t\t\tif (Timer.runtime() > 1000 || newState.me.gewonnen())\n\t\t\t\t\t\tmaxDepth = depth + 1\n\t\t\t\t\tif (depth < maxDepth && !state.enemy.gewonnen())\n\t\t\t\t\t\tqueue.add(stateNode.child(newState, points, subDir, move))\n\t\t\t\t}\n\t\t\t\tstateNode.points = bestLocal\n\t\t\t}\n\t\t\tif (Timer.runtime() > 1600)\n\t\t\t\tbreak\n\t\t\tnode = queue.pop()\n\t\t\tif (node.depth != depth) {\n\t\t\t\tval bestNode = rootNode.calculateBest()\n\t\t\t\tif (mp.obj != bestNode.move)\n\t\t\t\t\tdepthUsed = depth\n\t\t\t\tmp.update(bestNode.move, bestNode.points)\n\t\t\t\tlogger.info(\"Best move for depth $depth: $mp, accepted $acceptedMoves\")\n\t\t\t\tdepth = node.depth\n\t\t\t\tacceptedMoves = 0\n\t\t\t\tdivider = depth.toDouble().pow(0.3)\n\t\t\t}\n\t\t}\n\t\treturn mp.obj\n\t}\n\t\n\tprivate val queue = ArrayDeque<Node>(8000)\n\t\n\toverride fun clear() {\n\t\trootNode.children.clear()\n\t\tqueue.clear()\n\t}\n\t\n\tprivate val rootNode = Node(Move(), null, 0.0, 0, null)\n\t\n\tprivate class Node(@F val move: Move, @F var state: GameState?, @F var points: Double, @F val depth: Int, @F val dir: Path?) : Comparable<Node> {\n\t\t\n\t\tvar children = ArrayList<Node>()\n\t\t\n\t\tfun rootChild(move: Move, state: GameState, points: Double) =\n\t\t\t\tchild(state, points, currentLogDir?.resolve(\"%.1f - %s\".format(points, move.str()))?.createDir(), move)\n\t\t\n\t\tfun child(newState: GameState, newPoints: Double, dir: Path?, move: Move = this.move) =\n\t\t\t\tNode(move, newState, newPoints, depth + 1, dir).also { children.add(it) }\n\t\t\n\t\tfun popState() = state!!.also { state = null }\n\t\t\n\t\tfun calculateBest(): Node {\n\t\t\treturn if (children.firstOrNull()?.children?.isEmpty() != false) this\n\t\t\telse children.maxBy { child ->\n\t\t\t\tchild.children.map { it.calculateBest().points }.average().also {\n\t\t\t\t\tchild.points = it\n\t\t\t\t\t//if (isDebug && child.depth == 1) logger.debug(\"$child - ${child.children}\")\n\t\t\t\t}\n\t\t\t}!!\n\t\t}\n\t\t\n\t\toverride fun toString() = \"Node{%d for %s Points %.1f}\".format(depth, move.str(), points)\n\t\toverride fun compareTo(other: Node) = points.compareTo(other.points)\n\t}\n\t\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/xerus/softwarechallenge/logic2018/Jumper3.kt	(revision dd587f8e3923998f88757c77ab9d989331b87c3b)
+++ src/xerus/softwarechallenge/logic2018/Jumper3.kt	(date 1528172684000)
@@ -64,7 +64,7 @@
 				try {
 					move.perform(moveState)
 					var bestPoints = evaluate(moveState, myColor.opponent())
-					val newState = moveState.quickMove(false)!!.second
+					val newState = moveState.quickMove()!!.second
 					for (move2 in newState.findMoves()) {
 						val moveState2 = newState.clone()
 						move2.setOrderInActions()
Index: src/xerus/softwarechallenge/util/LogicHandler.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage xerus.softwarechallenge.util\n\nimport ch.qos.logback.classic.Level\nimport ch.qos.logback.classic.Logger\nimport org.slf4j.LoggerFactory\nimport sc.plugin2018.*\nimport sc.shared.*\nimport xerus.ktutil.*\nimport xerus.ktutil.helpers.Rater\nimport xerus.ktutil.helpers.Timer\nimport xerus.softwarechallenge.client\nimport java.io.File\nimport java.lang.management.ManagementFactory\nimport java.nio.file.Paths\nimport java.security.SecureRandom\nimport java.text.SimpleDateFormat\nimport java.util.*\nimport kotlin.math.sign\n\nvar strategy: String? = null\nvar debugLevel: Int = 1\nvar evolution: Int? = null\n\n/** schafft Grundlagen fuer eine Logik */\nabstract class LogicHandler : IGameHandler {\n\t\n\t@F protected val logger: Logger = LoggerFactory.getLogger(this.javaClass) as Logger\n\t\n\t@F protected var params = strategy?.split(',')?.map { it.toDouble() }?.toDoubleArray() ?: defaultParams()\n\t\n\t@F protected val rand: Random = SecureRandom()\n\t\n\t@F protected var currentState = GameState()\n\t\n\t@F protected val isDebug = debugLevel == 2\n\t\n\tprotected inline val currentPlayer: Player\n\t\tget() = currentState.currentPlayer\n\t\n\tprotected inline val currentTurn\n\t\tget() = currentState.turn\n\t\n\t@F val version = this.javaClass.simpleName + \" \" + getResource(\"version\")!!.readText()\n\t\n\tinit {\n\t\tlogger.warn(\"$version - Parameter: ${params.joinToString()}\")\n\t\tif (debugLevel == 2) {\n\t\t\tlogger.level = Level.DEBUG\n\t\t\tlogger.info(\"Debug enabled\")\n\t\t} else if (debugLevel == 1) {\n\t\t\tlogger.level = Level.INFO\n\t\t\tlogger.info(\"Info enabled\")\n\t\t}\n\t\tlogger.info(\"JVM args: \" + ManagementFactory.getRuntimeMXBean().inputArguments)\n\t}\n\t\n\toverride fun onRequestAction() {\n\t\tTimer.start()\n\t\tvalidMoves = 0\n\t\tinvalidMoves = 0\n\t\tdepth = 0\n\t\tdepthUsed = 0\n\t\tvar move: Move? = try {\n\t\t\tcurrentState.predefinedMove()\n\t\t} catch (e: Throwable) {\n\t\t\tlogger.error(\"Error in predefinedMove!\", e)\n\t\t\tnull\n\t\t}\n\t\t\n\t\tif (move.invalid()) {\n\t\t\tif (move != null)\n\t\t\t\tlogger.error(\"Invalid predefined Move: ${move.str()}\")\n\t\t\tmove = try {\n\t\t\t\tfindBestMove()\n\t\t\t} catch (e: Throwable) {\n\t\t\t\tlogger.error(\"Error in findBestMove!\", e)\n\t\t\t\tnull\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (move.invalid()) {\n\t\t\tif (move != null)\n\t\t\t\tlogger.error(\"Invalid findBestMove: ${move.str()}\")\n\t\t\ttry {\n\t\t\t\tmove = currentState.quickMove()?.first\n\t\t\t} catch (e: Throwable) {\n\t\t\t\tlogger.error(\"Error in quickMove!\", e)\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (move.invalid()) {\n\t\t\tlogger.error(\"No valid quickMove: {} - using simpleMove!\", move)\n\t\t\tmove = currentState.simpleMove()\n\t\t}\n\t\t\n\t\tif (Timer.runtime() < 100) {\n\t\t\tlogger.info(\"Invoking GC at ${Timer.runtime()}ms\")\n\t\t\tSystem.gc()\n\t\t}\n\t\tsendAction(move)\n\t\tlogger.info(\"Zeit: %sms Moves: %s/%s Tiefe: %s Genutzt: %s\".format(Timer.runtime(), validMoves, invalidMoves, depth, depthUsed))\n\t\tcurrentLogDir?.renameTo(gameLogDir!!.resolve(\"turn$currentTurn - ${move?.str()} - ${currentPlayer.str()}\"))\n\t\tclear()\n\t}\n\t\n\tfun Move?.invalid() = this == null || currentState.test(this, true, false) == null\n\t\n\t/** log directory for this game */\n\t@F val gameLogDir = if (isDebug) Paths.get(\"games\", SimpleDateFormat(\"MM-dd HH-mm-ss\").format(Date()) + \" $version\").createDirs() else null\n\t/** log directory for the current turn*/\n\tval currentLogDir\n\t\tget() = gameLogDir?.resolve(\"turn$currentTurn\")?.createDirs()\n\t\n\tprotected fun GameState.quickMove(recurse: Boolean = true): Pair<Move, GameState>? {\n\t\tval moves = findMoves()\n\t\tval best = Rater<Pair<Move, GameState>>()\n\t\tvar done: Boolean\n\t\tfor (move in moves) {\n\t\t\tval moveState = clone()\n\t\t\tmove.setOrderInActions()\n\t\t\ttry {\n\t\t\t\tmove.perform(moveState)\n\t\t\t\tdone = false\n\t\t\t\tif (turn < 58 && recurse) {\n\t\t\t\t\tval newState = moveState.quickMove(false)?.second\n\t\t\t\t\tif (newState != null) {\n\t\t\t\t\t\tdone = true\n\t\t\t\t\t\tfor (move2 in newState.findMoves()) {\n\t\t\t\t\t\t\tval moveState2 = newState.clone()\n\t\t\t\t\t\t\tmove2.setOrderInActions()\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tmove2.perform(moveState2)\n\t\t\t\t\t\t\t\tbest.update(Pair(move, moveState), evaluate(moveState2, currentPlayerColor))\n\t\t\t\t\t\t\t} catch (exception: Exception) {\n\t\t\t\t\t\t\t\tlogger.error(\"Fehler bei quickMove2: ${move2.str()} caused $exception\\n\" + str())\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else logger.error(\"Fehler bei quickMove2: No quickmove found!\\n\" + str())\n\t\t\t\t}\n\t\t\t\tif (!done)\n\t\t\t\t\tbest.update(Pair(move, moveState), evaluate(moveState, currentPlayerColor))\n\t\t\t} catch (exception: Exception) {\n\t\t\t\tlogger.error(\"Fehler bei quickMove: ${move.str()} caused $exception\\n\" + str())\n\t\t\t}\n\t\t}\n\t\treturn best.obj\n\t}\n\t\n\t/** if a predefined Move is appropriate then this method can return it, otherwise null */\n\tprotected open fun GameState.predefinedMove(): Move? = null\n\t\n\t/** finds relevant moves for this [GameState] */\n\tprotected abstract fun GameState.findMoves(): List<Move>\n\t\n\tprotected abstract fun GameState.simpleMove(): Move\n\t\n\t/** findet den Move der beim aktuellen GameState am besten ist */\n\tprotected abstract fun findBestMove(): Move?\n\t\n\t/** called after the Move is sent to allow resetting back to neutral */\n\tprotected open fun clear() {}\n\t\n\t/** bewertet die gegebene Situation\n\t * @return Einschätzung der gegebenen Situation in Punkten */\n\tabstract fun evaluate(state: GameState, color: PlayerColor = myColor): Double\n\t\n\tabstract fun defaultParams(): DoubleArray\n\t\n\t@F protected var depth: Int = 0\n\t@F protected var depthUsed: Int = 0\n\t\n\t// GRUNDLAGEN\n\t\n\toverride fun sendAction(move: Move?) {\n\t\tif (move == null) {\n\t\t\tlogger.warn(\"Kein Zug möglich!\")\n\t\t\tclient.sendMove(Move())\n\t\t\treturn\n\t\t}\n\t\tlogger.info(\"Sende {}\", move.str())\n\t\tmove.setOrderInActions()\n\t\tclient.sendMove(move)\n\t}\n\t\n\tprotected lateinit var myColor: PlayerColor\n\t\n\toverride fun onUpdate(state: GameState) {\n\t\tcurrentState = state\n\t\tval dran = state.currentPlayer\n\t\tif (!::myColor.isInitialized && client.color != null) {\n\t\t\tmyColor = client.color\n\t\t\tlogger.info(\"Ich bin {}, \" + state.str(), myColor)\n\t\t}\n\t\tlogger.info(\"Zug: {} Dran: {} - \" + dran.str(), state.turn, dran.playerColor.identify())\n\t}\n\t\n\tfun Player.str() = strShort() + \" [${cards.joinToString { it.name }}] Last: ${lastNonSkipAction?.str()}\"\n\t\n\tprotected inline fun Player.strShort() =\n\t\t\t\"$playerColor on $fieldIndex=${fieldTypeAt(fieldIndex).str()} ❦$carrots ❀$salads\"\n\t\n\tprotected inline fun Player.strShortest() =\n\t\t\t\"$fieldIndex=${fieldTypeAt(fieldIndex).str()} ❦$carrots\"\n\t\n\tfun GameState.str() =\n\t\t\t\"GameState: Turn $turn ${this.board.track.joinToString(\", \", \"Track[\", \"]\") { \"${it.index} ${it.type}\" }}\\n\" +\n\t\t\t\t\t\" - current: ${currentPlayer.str()}\\n\" +\n\t\t\t\t\t\" - other: ${otherPlayer.str()}\"\n\t\n\tfun GameState.strShort() =\n\t\t\t\"GameState: Turn $turn - Current: ${currentPlayer.strShort()} - Other: ${otherPlayer.strShort()}\"\n\t\n\tprotected fun fieldTypeAt(index: Int): FieldType = currentState.getTypeAt(index)\n\t\n\tfun findField(type: FieldType, startIndex: Int = currentPlayer.fieldIndex + 1): Int {\n\t\tvar index = startIndex\n\t\twhile (fieldTypeAt(index) != type)\n\t\t\tindex++\n\t\treturn index\n\t}\n\t\n\t/** searches for the given [FieldType] around the [startIndex], back and forth starting in the front\n\t * @return index of the nearest [Field] matching [type] in any direction */\n\tfun findCircular(type: FieldType, startIndex: Int): Int {\n\t\tvar index = startIndex\n\t\tvar dif = 1\n\t\twhile (fieldTypeAt(index) != type) {\n\t\t\tindex += dif\n\t\t\tdif = -(dif + dif.sign)\n\t\t}\n\t\treturn index\n\t}\n\t\n\t// Zugmethoden\n\t\n\t/** performs the [action] on this [GameState]\n\t * @return false if it fails */\n\tprotected fun GameState.perform(action: Action): Boolean =\n\t\t\ttry {\n\t\t\t\taction.perform(this)\n\t\t\t\ttrue\n\t\t\t} catch (e: InvalidMoveException) {\n\t\t\t\tfalse\n\t\t\t}\n\t\n\t/**\n\t * tests a Move against this [GameState] and then executes a move for the enemy player if requested\n\t *\n\t * @param clone if the state should be cloned prior to performing\n\t * @param moveOther\n\t * @return null if there was an error, otherwise the GameState after the performing the Move\n\t */\n\tprotected fun GameState.test(move: Move, clone: Boolean = true, moveOther: Boolean = true): GameState? {\n\t\tval newState = clone()\n\t\ttry {\n\t\t\tmove.setOrderInActions()\n\t\t\tmove.perform(newState)\n\t\t\tval bestState = Rater<GameState>()\n\t\t\tif (moveOther) {\n\t\t\t\tif (newState.turn < 60 && newState.otherPlayer.fieldIndex != 64) {\n\t\t\t\t\tfor (otherMove in newState.findMoves()) {\n\t\t\t\t\t\tval moveState = newState.clone()\n\t\t\t\t\t\totherMove.setOrderInActions()\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\totherMove.perform(moveState)\n\t\t\t\t\t\t\tbestState.update(moveState, evaluate(moveState, myColor.opponent()))\n\t\t\t\t\t\t} catch (exception: Throwable) {\n\t\t\t\t\t\t\tlogger.error(\"Fehler bei otherMove: ${otherMove.str()} for ${newState.currentPlayer.str()}: $exception\\nnew ${newState.str()}\\n\" + if (clone) \"prev \" + this.str() else \"Not cloned!\")\n\t\t\t\t\t\t\tnewState.nextPlayer()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnewState.nextPlayer(newState.turn < 60)\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvalidMoves++\n\t\t\treturn bestState.obj ?: newState\n\t\t} catch (e: InvalidGameStateException) {\n\t\t\tlogger.error(\"$e ${move.str()} current: $currentTurn\")\n\t\t} catch (e: InvalidMoveException) {\n\t\t\tif (debugLevel > 0)\n\t\t\t\tlogger.error(\"FEHLERHAFTER ZUG: {} FEHLER: {}\\n\" + this.str(), move.str(), e.message)\n\t\t} catch (e: Throwable) {\n\t\t\tlogger.error(\"Testing ${move.str()} failed!\", e)\n\t\t}\n\t\tinvalidMoves++\n\t\treturn null\n\t}\n\t\n\tprotected fun GameState.nextPlayer(forward: Boolean = true) {\n\t\tturn += if (forward) 1 else -1\n\t\tswitchCurrentPlayer()\n\t}\n\t\n\t@F protected var validMoves: Int = 0\n\t@F protected var invalidMoves: Int = 0\n\t\n\toverride fun gameEnded(data: GameResult, color: PlayerColor, errorMessage: String?) {\n\t\tval scores = data.scores\n\t\tval cause = \"Ich %s Gegner %s\".format(scores[color.ordinal].cause, scores[color.opponent().ordinal].cause)\n\t\tif (data.winners.isEmpty())\n\t\t\tlogger.warn(\"Kein Gewinner! Grund: {}\", cause)\n\t\tval winner = (data.winners[0] as Player).playerColor\n\t\tval score = getScore(scores, color)\n\t\tval regular = data.isRegular\n\t\tif (regular)\n\t\t\tlogger.warn(\"Spiel beendet! Gewinner: ${winner.identify()} Punkte: $score Gegner: ${getScore(scores, color.opponent())}\")\n\t\telse\n\t\t\tlogger.warn(\"Spiel unregulaer beendet! Punkte: $score Grund: $cause\")\n\t\tevolution?.let {\n\t\t\tFile(\"result$it\").writeText(\"${regular.to((color == winner).toInt(), -1)} $score\")\n\t\t}\n\t}\n\t\n\tprivate fun getScore(scores: List<PlayerScore>, color: PlayerColor): Int =\n\t\t\tscores[color.ordinal].values[1].toInt()\n\t\n\toverride fun onUpdate(arg0: Player, arg1: Player) {}\n\t\n\tprivate fun PlayerColor.identify(): String =\n\t\t\tif (this == myColor) \"me\" else \"other\"\n\t\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/xerus/softwarechallenge/util/LogicHandler.kt	(revision dd587f8e3923998f88757c77ab9d989331b87c3b)
+++ src/xerus/softwarechallenge/util/LogicHandler.kt	(date 1528172641000)
@@ -113,34 +113,30 @@
 	val currentLogDir
 		get() = gameLogDir?.resolve("turn$currentTurn")?.createDirs()
 	
-	protected fun GameState.quickMove(recurse: Boolean = true): Pair<Move, GameState>? {
+	protected fun GameState.quickMove(): Pair<Move, GameState>? {
 		val moves = findMoves()
 		val best = Rater<Pair<Move, GameState>>()
-		var done: Boolean
 		for (move in moves) {
 			val moveState = clone()
 			move.setOrderInActions()
 			try {
 				move.perform(moveState)
-				done = false
-				if (turn < 58 && recurse) {
-					val newState = moveState.quickMove(false)?.second
-					if (newState != null) {
-						done = true
-						for (move2 in newState.findMoves()) {
-							val moveState2 = newState.clone()
-							move2.setOrderInActions()
-							try {
-								move2.perform(moveState2)
-								best.update(Pair(move, moveState), evaluate(moveState2, currentPlayerColor))
-							} catch (exception: Exception) {
-								logger.error("Fehler bei quickMove2: ${move2.str()} caused $exception\n" + str())
-							}
+				if(turn < 58) {
+					moveState.nextPlayer()
+					for (move2 in moveState.findMoves()) {
+						val moveState2 = moveState.clone()
+						move2.setOrderInActions()
+						try {
+							move2.perform(moveState2)
+							best.update(Pair(move, moveState), evaluate(moveState2, currentPlayerColor))
+						} catch (exception: Exception) {
+							logger.error("Fehler bei quickMove2: ${move2.str()} caused $exception\n" + str())
 						}
-					} else logger.error("Fehler bei quickMove2: No quickmove found!\n" + str())
-				}
-				if (!done)
+					}
+					moveState.nextPlayer(false)
+				} else {
 					best.update(Pair(move, moveState), evaluate(moveState, currentPlayerColor))
+				}
 			} catch (exception: Exception) {
 				logger.error("Fehler bei quickMove: ${move.str()} caused $exception\n" + str())
 			}
