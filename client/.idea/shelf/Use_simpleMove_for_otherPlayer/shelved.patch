Index: src/xerus/softwarechallenge/util/LogicHandler.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package xerus.softwarechallenge.util\n\nimport ch.qos.logback.classic.Level\nimport ch.qos.logback.classic.Logger\nimport org.slf4j.LoggerFactory\nimport sc.plugin2018.*\nimport sc.shared.*\nimport xerus.ktutil.*\nimport xerus.ktutil.helpers.Rater\nimport xerus.ktutil.helpers.Timer\nimport xerus.softwarechallenge.client\nimport java.io.File\nimport java.lang.management.ManagementFactory\nimport java.nio.file.Paths\nimport java.security.SecureRandom\nimport java.text.SimpleDateFormat\nimport java.util.*\nimport kotlin.math.sign\n\nvar strategy: String? = null\nvar debugLevel: Int = 1\nvar evolution: Int? = null\n\n/** schafft Grundlagen fuer eine Logik */\nabstract class LogicHandler : IGameHandler {\n\t\n\t@F protected val logger: Logger = LoggerFactory.getLogger(this.javaClass) as Logger\n\t\n\t@F protected var params = strategy?.split(',')?.map { it.toDouble() }?.toDoubleArray() ?: defaultParams()\n\t\n\t@F protected val rand: Random = SecureRandom()\n\t\n\t@F protected var currentState = GameState()\n\t\n\t@F protected val isDebug = debugLevel == 2\n\t\n\tprotected inline val currentPlayer: Player\n\t\tget() = currentState.currentPlayer\n\t\n\tprotected inline val currentTurn\n\t\tget() = currentState.turn\n\t\n\t@F val version = this.javaClass.simpleName + \"-\" + getResource(\"version\")!!.openStream().reader().readText()\n\t\n\tinit {\n\t\tlogger.warn(\"$version - Parameter: ${params.joinToString()}\")\n\t\tif (debugLevel == 2) {\n\t\t\tlogger.level = Level.DEBUG\n\t\t\tlogger.info(\"Debug enabled\")\n\t\t} else if (debugLevel == 1) {\n\t\t\tlogger.level = Level.INFO\n\t\t\tlogger.info(\"Info enabled\")\n\t\t}\n\t\tlogger.info(\"JVM args: \" + ManagementFactory.getRuntimeMXBean().inputArguments)\n\t}\n\t\n\toverride fun onRequestAction() {\n\t\tTimer.start()\n\t\tvalidMoves = 0\n\t\tinvalidMoves = 0\n\t\tdepth = 0\n\t\tdepthUsed = 0\n\t\tvar move: Move? = try {\n\t\t\tcurrentState.predefinedMove()\n\t\t} catch (e: Throwable) {\n\t\t\tlogger.error(\"Error in predefinedMove!\", e)\n\t\t\tnull\n\t\t}\n\t\t\n\t\tif (move.invalid()) {\n\t\t\tif (move != null)\n\t\t\t\tlogger.error(\"Invalid predefined Move: ${move.str()}\")\n\t\t\tmove = try {\n\t\t\t\tfindBestMove()\n\t\t\t} catch (e: Throwable) {\n\t\t\t\tlogger.error(\"Error in findBestMove!\", e)\n\t\t\t\tnull\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (move.invalid()) {\n\t\t\tif (move != null)\n\t\t\t\tlogger.error(\"Invalid findBestMove: ${move.str()}\")\n\t\t\tmove = try {\n\t\t\t\tcurrentState.quickMove().first\n\t\t\t} catch (e: Throwable) {\n\t\t\t\tlogger.error(\"Error in quickMove!\", e)\n\t\t\t\tnull\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (move.invalid()) {\n\t\t\tlogger.info(\"No valid Move: {} - using simpleMove!\", move)\n\t\t\tmove = currentState.simpleMove()\n\t\t}\n\t\t\n\t\tif (Timer.runtime() < 100) {\n\t\t\tlogger.info(\"Invoking GC at ${Timer.runtime()}ms\")\n\t\t\tSystem.gc()\n\t\t}\n\t\tsendAction(move)\n\t\tlogger.info(\"Zeit: %sms Moves: %s/%s Tiefe: %s Genutzt: %s\".format(Timer.runtime(), validMoves, invalidMoves, depth, depthUsed))\n\t\tcurrentLogDir?.renameTo(gameLogDir!!.resolve(\"turn$currentTurn - ${move?.str()}\"))\n\t\tclear()\n\t}\n\t\n\tfun Move?.invalid() = this == null || currentState.test(this, true, false) == null\n\t\n\t// region Zugsuche\n\t\n\t/** log directory for this game */\n\t@F val gameLogDir = if (isDebug) Paths.get(\"games\", SimpleDateFormat(\"MM-dd HH-mm-ss\").format(Date()) + \" $version\").createDirs() else null\n\t/** log directory for the current turn*/\n\tval currentLogDir\n\t\tget() = gameLogDir?.resolve(\"turn$currentTurn\")?.createDirs()\n\t\n\tprotected fun GameState.quickMove(): Pair<Move, GameState> {\n\t\tval moves = findMoves()\n\t\tval best = Rater<Pair<Move, GameState>>()\n\t\tfor (move in moves) {\n\t\t\tval moveState = clone()\n\t\t\tmove.setOrderInActions()\n\t\t\tmove.perform(moveState)\n\t\t\tmoveState.turn -= 1\n\t\t\tmoveState.switchCurrentPlayer()\n\t\t\tif (best.points < evaluate(moveState)) {\n\t\t\t\tmoveState.turn += 1\n\t\t\t\tmoveState.switchCurrentPlayer()\n\t\t\t\tbest.obj = Pair(move, moveState)\n\t\t\t}\n\t\t}\n\t\treturn best.obj!!\n\t}\n\t\n\t/** if a predefined Move is appropriate then this method can return it, otherwise null */\n\tprotected open fun GameState.predefinedMove(): Move? = null\n\t\n\t/** finds relevant moves for this [GameState] */\n\tprotected abstract fun GameState.findMoves(): List<Move>\n\t\n\tprotected abstract fun GameState.simpleMove(): Move\n\t\n\t/** findet den Move der beim aktuellen GameState am besten ist */\n\tprotected abstract fun findBestMove(): Move?\n\t\n\t/** called after the Move is sent to allow resetting back to neutral */\n\tprotected open fun clear() {}\n\t\n\t/** bewertet die gegebene Situation\n\t * @return Einschätzung der gegebenen Situation in Punkten */\n\tabstract fun evaluate(state: GameState): Double\n\t\n\tabstract fun defaultParams(): DoubleArray\n\t\n\t@F protected var depth: Int = 0\n\t@F protected var depthUsed: Int = 0\n\t\n\t// GRUNDLAGEN\n\t\n\toverride fun sendAction(move: Move?) {\n\t\tif (move == null) {\n\t\t\tlogger.warn(\"Kein Zug möglich!\")\n\t\t\tclient.sendMove(Move())\n\t\t\treturn\n\t\t}\n\t\tlogger.info(\"Sende {}\", move.str())\n\t\tmove.setOrderInActions()\n\t\tclient.sendMove(move)\n\t}\n\t\n\tprotected lateinit var myColor: PlayerColor\n\t\n\toverride fun onUpdate(state: GameState) {\n\t\tcurrentState = state\n\t\tval dran = state.currentPlayer\n\t\tif (!::myColor.isInitialized && client.color != null) {\n\t\t\tmyColor = client.color\n\t\t\tlogger.info(\"Ich bin {}\", myColor)\n\t\t}\n\t\tlogger.info(\"Zug: {} Dran: {} - \" + dran.str(), state.turn, dran.playerColor.identify())\n\t}\n\t\n\t/*public static void display(GameState state) {\n\t\tJFrame frame = new JFrame();\n\t\tString fieldString = state.getBoard().toString();\n\t\tMyTable table = new ScrollableJTable(\"Index\", \"Field\").addToComponent(frame, null);\n\t\tString[] fields = fieldString.split(\"index \\\\d+\");\n\t\tfor (int i = 1; i < fields.length - 1; i++) {\n\t\t\ttable.addRow(i + \"\", fields[i]);\n\t\t}\n\t\ttable.fitColumns(0);\n\t\tframe.pack();\n\t\tframe.setVisible(true);\n\t}*/\n\t\n\tabstract fun Player.str(): String\n\t\n\tfun GameState.str() =\n\t\t\t\"GameState: Zug %d\\n - current: %s\\n - other: %s\".format(turn, currentPlayer.str(), otherPlayer.str())\n\t\n\tprotected fun fieldTypeAt(index: Int): FieldType = currentState.getTypeAt(index)\n\t\n\tfun findField(type: FieldType, startIndex: Int = currentPlayer.fieldIndex + 1): Int {\n\t\tvar index = startIndex\n\t\twhile (fieldTypeAt(index) != type)\n\t\t\tindex++\n\t\treturn index\n\t}\n\t\n\t/** searches for the given [FieldType] around the [startIndex], back and forth starting in the front\n\t * @return index of the nearest [Field] matching [type] in any direction */\n\tfun findCircular(type: FieldType, startIndex: Int): Int {\n\t\tvar index = startIndex\n\t\tvar dif = 1\n\t\twhile (fieldTypeAt(index) != type) {\n\t\t\tindex += dif\n\t\t\tdif = -(dif + dif.sign)\n\t\t}\n\t\treturn index\n\t}\n\t\n\t// Zugmethoden\n\t\n\t/** performs the [action] on this [GameState]\n\t * @return false if it fails */\n\tprotected fun GameState.perform(action: Action): Boolean =\n\t\t\ttry {\n\t\t\t\taction.perform(this)\n\t\t\t\ttrue\n\t\t\t} catch (e: InvalidMoveException) {\n\t\t\t\tfalse\n\t\t\t}\n\t\n\t/**\n\t * tests a Move against this [GameState] and then executes a move for the enemy player\n\t *\n\t * @param state gegebener State\n\t * @param move  der zu testende Move\n\t * @param clone if the state should be cloned prior to performing\n\t * @return null, wenn der Move fehlerhaft ist, sonst den GameState nach dem Move\n\t */\n\tprotected fun GameState.test(move: Move, clone: Boolean = true, moveOther: Boolean = true): GameState? {\n\t\tval newState = clone()//if (clone) clone() else this\n\t\ttry {\n\t\t\tmove.setOrderInActions()\n\t\t\tmove.perform(newState)\n\t\t\tval bestState = Rater<GameState>()\n\t\t\tif (moveOther && newState.turn < 60 && newState.otherPlayer.fieldIndex != 64) {\n\t\t\t\tfor (otherMove in newState.findMoves()) {\n\t\t\t\t\tval moveState = newState.clone()\n\t\t\t\t\totherMove.setOrderInActions()\n\t\t\t\t\ttry {\n\t\t\t\t\t\totherMove.perform(moveState)\n\t\t\t\t\t\tmoveState.turn -= 1\n\t\t\t\t\t\tmoveState.switchCurrentPlayer()\n\t\t\t\t\t\tif (bestState.update(moveState, evaluate(moveState))) {\n\t\t\t\t\t\t\tmoveState.turn += 1\n\t\t\t\t\t\t\tmoveState.switchCurrentPlayer()\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (exception: Throwable) {\n\t\t\t\t\t\tlogger.warn(\"Fehler bei otherMove: ${otherMove.str()} for ${newState.currentPlayer.str()}: $exception\\nnew ${newState.str()}\\n\" + if (clone) \"prev \" + this.str() else \"Not cloned!\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvalidMoves++\n\t\t\treturn bestState.obj ?: newState.apply {\n\t\t\t\tturn += 1\n\t\t\t\tswitchCurrentPlayer()\n\t\t\t}\n\t\t} catch (e: InvalidMoveException) {\n\t\t\tinvalidMoves++\n\t\t\tif (debugLevel > 0)\n\t\t\t\tlogger.warn(\"FEHLERHAFTER ZUG: {} FEHLER: {}\\n\" + this.str(), move.str(), e.message)\n\t\t}\n\t\treturn null\n\t}\n\t\n\t@F protected var validMoves: Int = 0\n\t@F protected var invalidMoves: Int = 0\n\t\n\toverride fun gameEnded(data: GameResult, color: PlayerColor, errorMessage: String?) {\n\t\tval scores = data.scores\n\t\tval cause = \"Ich %s Gegner %s\".format(scores[color.ordinal].cause, scores[color.opponent().ordinal].cause)\n\t\tif (data.winners.isEmpty())\n\t\t\tlogger.warn(\"Kein Gewinner! Grund: {}\", cause)\n\t\tval winner = (data.winners[0] as Player).playerColor\n\t\tval score = getScore(scores, color)\n\t\tif (data.isRegular)\n\t\t\tlogger.warn(\"Spiel beendet! Gewinner: %s Punkte: %s Gegner: %s\".format(winner.identify(), score, getScore(scores, color.opponent())))\n\t\telse\n\t\t\tlogger.warn(\"Spiel unregulaer beendet! Punkte: %s Grund: %s\".format(score, cause))\n\t\tevolution?.let {\n\t\t\tFile(\"evolution/result$it\").writeText(\"${(color == winner).toInt()} $score\")\n\t\t}\n\t}\n\t\n\tprivate fun getScore(scores: List<PlayerScore>, color: PlayerColor): Int =\n\t\t\tscores[color.ordinal].values[1].toInt()\n\t\n\toverride fun onUpdate(arg0: Player, arg1: Player) {}\n\t\n\tprivate fun PlayerColor.identify(): String =\n\t\t\tif (this == myColor) \"me\" else \"other\"\n\t\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/xerus/softwarechallenge/util/LogicHandler.kt	(date 1527288605000)
+++ src/xerus/softwarechallenge/util/LogicHandler.kt	(date 1527416027000)
@@ -244,30 +244,21 @@
 		try {
 			move.setOrderInActions()
 			move.perform(newState)
-			val bestState = Rater<GameState>()
-			if (moveOther && newState.turn < 60 && newState.otherPlayer.fieldIndex != 64) {
-				for (otherMove in newState.findMoves()) {
-					val moveState = newState.clone()
-					otherMove.setOrderInActions()
-					try {
-						otherMove.perform(moveState)
-						moveState.turn -= 1
-						moveState.switchCurrentPlayer()
-						if (bestState.update(moveState, evaluate(moveState))) {
-							moveState.turn += 1
-							moveState.switchCurrentPlayer()
-						}
-					} catch (exception: Throwable) {
-						logger.warn("Fehler bei otherMove: ${otherMove.str()} for ${newState.currentPlayer.str()}: $exception\nnew ${newState.str()}\n" + if (clone) "prev " + this.str() else "Not cloned!")
-					}
+			val turnIndex = newState.turn
+			if (moveOther && turnIndex < 60) {
+				val simpleMove = newState.simpleMove()
+				try {
+					simpleMove.perform(newState)
+				} catch (exception: Throwable) {
+					logger.warn("Fehler bei simpleMove ${simpleMove.str()} - ${this.otherPlayer.str()}: $exception\n${newState.str()}")
+					newState.nextPlayer()
 				}
+			} else {
+				newState.nextPlayer()
 			}
 			
 			validMoves++
-			return bestState.obj ?: newState.apply {
-				turn += 1
-				switchCurrentPlayer()
-			}
+			return newState
 		} catch (e: InvalidMoveException) {
 			invalidMoves++
 			if (debugLevel > 0)
